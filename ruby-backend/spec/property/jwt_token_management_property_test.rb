# Property-based test for JWT token management
# **Feature: ruby-backend-migration, Property 4: JWT Token Management**
# **Validates: Requirements 2.2, 2.4, 2.5**

require 'bundler/setup'
require 'rspec'
require 'rantly'
require 'rantly/rspec_extensions'
require 'bcrypt'
require 'securerandom'
require 'jwt'
require 'time'

# Set test environment
ENV['APP_ENV'] = 'test'
ENV['JWT_SECRET'] = 'test_jwt_secret_key_for_testing_purposes_only'
ENV['JWT_TTL'] = '60' # 1 hour for testing

RSpec.describe 'JWT Token Management Property Test', :property do
  before(:all) do
    # Load configuration
    require_relative '../../config/settings'
    
    # Load test database configuration
    require_relative '../../config/test_database'
    
    # Override the DB constant for testing
    Object.send(:remove_const, :DB) if defined?(DB)
    DB = SpotikConfig::TestDatabase.connection
    
    # Load models and services with test database
    require_relative '../../app/models/user'
    require_relative '../../app/services/auth_service'
    
    # Finalize associations
    Sequel::Model.finalize_associations
  end
  
  before(:each) do
    # Clean database before each test
    DB[:users].delete
  end

  describe 'Property 4: JWT Token Management' do
    it 'ensures any JWT token generated by the system is valid for authentication until expiration' do
      test_instance = self
      
      property_of {
        # Generate valid user credentials
        user_data = test_instance.generate_valid_user_credentials
        # Generate various time scenarios within valid range
        time_offset_seconds = rand(0...(SpotikConfig::Settings.jwt_ttl * 60 - 10)) # Within TTL minus 10 seconds buffer
        [user_data, time_offset_seconds]
      }.check(10) { |user_data, time_offset_seconds|  # Reduced iterations for faster execution
        # Create user and generate JWT token
        user = create_legacy_compatible_user(user_data)
        jwt_token = AuthService.generate_jwt(user)
        
        # Verify token is valid immediately after generation
        auth_data = AuthService.validate_jwt(jwt_token)
        expect(auth_data).not_to be_nil
        expect(auth_data[:user].id).to eq(user.id)
        expect(auth_data[:token]).to eq(jwt_token)
        
        # Simulate time passage within valid period
        allow(Time).to receive(:now).and_return(Time.now + time_offset_seconds)
        
        # Verify token is still valid within expiration time
        auth_data_later = AuthService.validate_jwt(jwt_token)
        expect(auth_data_later).not_to be_nil
        expect(auth_data_later[:user].id).to eq(user.id)
        expect(auth_data_later[:token]).to eq(jwt_token)
        
        # Verify payload claims are consistent
        payload = auth_data_later[:payload]
        expect(payload['user_id']).to eq(user.id)
        expect(payload['username']).to eq(user.username)
        expect(payload['email']).to eq(user.email)
        expect(payload['sub']).to eq(user.id.to_s)
        expect(payload['iss']).to eq('spotik-ruby')
        
        # Verify expiration time is still in the future
        expect(payload['exp']).to be > Time.now.to_i
        
        # Reset time mock
        allow(Time).to receive(:now).and_call_original
      }
    end

    it 'ensures any expired JWT token is rejected by the system' do
      test_instance = self
      
      property_of {
        # Generate valid user credentials
        user_data = test_instance.generate_valid_user_credentials
        # Generate various expiration scenarios (1 second to 1 hour past expiration)
        expiration_offset_seconds = rand(1..3600) # 1 second to 1 hour past expiration
        [user_data, expiration_offset_seconds]
      }.check(10) { |user_data, expiration_offset_seconds|  # Reduced iterations for faster execution
        # Create user and generate JWT token
        user = create_legacy_compatible_user(user_data)
        jwt_token = AuthService.generate_jwt(user)
        
        # Verify token is valid initially
        auth_data = AuthService.validate_jwt(jwt_token)
        expect(auth_data).not_to be_nil
        
        # Simulate time passage beyond expiration
        future_time = Time.now + (SpotikConfig::Settings.jwt_ttl * 60) + expiration_offset_seconds
        allow(Time).to receive(:now).and_return(future_time)
        
        # Verify expired token is rejected with proper error
        expect {
          AuthService.validate_jwt(jwt_token)
        }.to raise_error(AuthenticationError) do |error|
          expect(error.code).to eq(:token_expired)
          expect(error.message).to include('expired')
        end
        
        # Reset time mock
        allow(Time).to receive(:now).and_call_original
      }
    end

    it 'maintains consistent token validation behavior across different token formats' do
      test_instance = self
      
      property_of {
        # Generate user and token format scenarios
        user_data = test_instance.generate_valid_user_credentials
        token_format = choose(:plain_token, :bearer_token, :bearer_lowercase, :bearer_with_spaces)
        [user_data, token_format]
      }.check(10) { |user_data, token_format|  # Reduced iterations for faster execution
        # Create user and generate JWT token
        user = create_legacy_compatible_user(user_data)
        jwt_token = AuthService.generate_jwt(user)
        
        # Format token according to test scenario
        formatted_token = case token_format
        when :plain_token
          jwt_token
        when :bearer_token
          "Bearer #{jwt_token}"
        when :bearer_lowercase
          "bearer #{jwt_token}"
        when :bearer_with_spaces
          "Bearer  #{jwt_token}  "
        end
        
        # Verify token validation works regardless of format
        auth_data = AuthService.validate_jwt(formatted_token)
        expect(auth_data).not_to be_nil
        expect(auth_data[:user].id).to eq(user.id)
        expect(auth_data[:token].strip).to eq(jwt_token.strip) # Should always return clean token
        
        # Verify payload is consistent
        payload = auth_data[:payload]
        expect(payload['user_id']).to eq(user.id)
        expect(payload['username']).to eq(user.username)
        expect(payload['email']).to eq(user.email)
      }
    end

    it 'ensures JWT tokens have proper expiration timing and cannot be used beyond TTL' do
      test_instance = self
      
      property_of {
        # Generate user and various TTL scenarios
        user_data = test_instance.generate_valid_user_credentials
        # Test different points around expiration boundary
        time_scenario = choose(:just_before_expiry, :at_expiry, :just_after_expiry, :long_after_expiry)
        [user_data, time_scenario]
      }.check(10) { |user_data, time_scenario|  # Reduced iterations for faster execution
        # Create user and generate JWT token
        user = create_legacy_compatible_user(user_data)
        jwt_token = AuthService.generate_jwt(user)
        
        # Get token payload to check expiration
        decoded = JWT.decode(jwt_token, nil, false)
        payload = decoded[0]
        exp_time = Time.at(payload['exp'])
        
        # Verify expiration is set correctly (TTL minutes from now)
        expected_exp = Time.now + (SpotikConfig::Settings.jwt_ttl * 60)
        expect(exp_time).to be_within(5).of(expected_exp) # 5 second tolerance
        
        # Test different time scenarios
        case time_scenario
        when :just_before_expiry
          # 10 seconds before expiry - should be valid
          test_time = exp_time - 10
          allow(Time).to receive(:now).and_return(test_time)
          
          auth_data = AuthService.validate_jwt(jwt_token)
          expect(auth_data).not_to be_nil
          expect(auth_data[:user].id).to eq(user.id)
          
        when :at_expiry
          # Exactly at expiry - should be expired
          allow(Time).to receive(:now).and_return(exp_time)
          
          expect {
            AuthService.validate_jwt(jwt_token)
          }.to raise_error(AuthenticationError) do |error|
            expect(error.code).to eq(:token_expired)
          end
          
        when :just_after_expiry
          # 1 second after expiry - should be expired
          test_time = exp_time + 1
          allow(Time).to receive(:now).and_return(test_time)
          
          expect {
            AuthService.validate_jwt(jwt_token)
          }.to raise_error(AuthenticationError) do |error|
            expect(error.code).to eq(:token_expired)
          end
          
        when :long_after_expiry
          # 1 hour after expiry - should be expired
          test_time = exp_time + 3600
          allow(Time).to receive(:now).and_return(test_time)
          
          expect {
            AuthService.validate_jwt(jwt_token)
          }.to raise_error(AuthenticationError) do |error|
            expect(error.code).to eq(:token_expired)
          end
        end
        
        # Reset time mock
        allow(Time).to receive(:now).and_call_original
      }
    end

    it 'ensures JWT token refresh works correctly within grace period and fails outside it' do
      test_instance = self
      
      property_of {
        # Generate user and refresh scenarios
        user_data = test_instance.generate_valid_user_credentials
        refresh_scenario = choose(:valid_token, :expired_within_grace, :expired_beyond_grace)
        [user_data, refresh_scenario]
      }.check(10) { |user_data, refresh_scenario|  # Reduced iterations for faster execution
        # Create user and generate JWT token
        user = create_legacy_compatible_user(user_data)
        jwt_token = AuthService.generate_jwt(user)
        
        case refresh_scenario
        when :valid_token
          # Token is still valid - refresh should work
          new_token = AuthService.refresh_jwt(jwt_token)
          expect(new_token).to be_a(String)
          expect(new_token).not_to eq(jwt_token) # Should be a new token
          
          # Verify new token is valid
          auth_data = AuthService.validate_jwt(new_token)
          expect(auth_data).not_to be_nil
          expect(auth_data[:user].id).to eq(user.id)
          
        when :expired_within_grace
          # Token is expired but within grace period (2x TTL)
          ttl_seconds = SpotikConfig::Settings.jwt_ttl * 60
          
          # Create a token that's expired but within grace period
          expired_token = create_expired_token_within_grace(user, ttl_seconds)
          
          # Refresh should work within grace period
          new_token = AuthService.refresh_jwt(expired_token)
          expect(new_token).to be_a(String)
          expect(new_token).not_to eq(expired_token)
          
          # Verify new token is valid
          auth_data = AuthService.validate_jwt(new_token)
          expect(auth_data).not_to be_nil
          expect(auth_data[:user].id).to eq(user.id)
          
        when :expired_beyond_grace
          # Token is expired beyond grace period (2x TTL)
          ttl_seconds = SpotikConfig::Settings.jwt_ttl * 60
          beyond_grace_time = Time.now + ttl_seconds + (ttl_seconds * 2) + 1 # Beyond 2x TTL
          allow(Time).to receive(:now).and_return(beyond_grace_time)
          
          # Refresh should fail beyond grace period
          expect {
            AuthService.refresh_jwt(jwt_token)
          }.to raise_error(AuthenticationError) do |error|
            expect(error.code).to eq(:token_expired)
          end
        end
        
        # Reset time mock
        allow(Time).to receive(:now).and_call_original
      }
    end

    it 'ensures JWT tokens maintain security properties and cannot be tampered with' do
      test_instance = self
      
      property_of {
        # Generate user and tampering scenarios
        user_data = test_instance.generate_valid_user_credentials
        tampering_type = choose(:modified_payload, :modified_signature, :wrong_secret, :different_algorithm)
        [user_data, tampering_type]
      }.check(10) { |user_data, tampering_type|  # Reduced iterations for faster execution
        # Create user and generate JWT token
        user = create_legacy_compatible_user(user_data)
        jwt_token = AuthService.generate_jwt(user)
        
        # Verify original token is valid
        auth_data = AuthService.validate_jwt(jwt_token)
        expect(auth_data).not_to be_nil
        
        # Create tampered token based on scenario
        tampered_token = case tampering_type
        when :modified_payload
          # Modify the payload (change user_id)
          parts = jwt_token.split('.')
          payload = JSON.parse(Base64.decode64(parts[1]))
          payload['user_id'] = 99999 # Different user ID
          modified_payload = Base64.encode64(payload.to_json).gsub(/\n/, '')
          "#{parts[0]}.#{modified_payload}.#{parts[2]}"
          
        when :modified_signature
          # Modify the signature
          parts = jwt_token.split('.')
          modified_signature = Base64.encode64('fake_signature').gsub(/\n/, '')
          "#{parts[0]}.#{parts[1]}.#{modified_signature}"
          
        when :wrong_secret
          # Generate token with wrong secret
          payload = {
            iss: 'spotik-ruby',
            iat: Time.now.to_i,
            exp: Time.now.to_i + 3600,
            nbf: Time.now.to_i,
            sub: user.id.to_s,
            jti: SecureRandom.hex(16),
            user_id: user.id,
            username: user.username,
            email: user.email
          }
          JWT.encode(payload, 'wrong_secret', 'HS256')
          
        when :different_algorithm
          # Generate token with different algorithm
          payload = {
            iss: 'spotik-ruby',
            iat: Time.now.to_i,
            exp: Time.now.to_i + 3600,
            nbf: Time.now.to_i,
            sub: user.id.to_s,
            jti: SecureRandom.hex(16),
            user_id: user.id,
            username: user.username,
            email: user.email
          }
          JWT.encode(payload, SpotikConfig::Settings.jwt_secret, 'HS512') # Different algorithm
        end
        
        # Verify tampered token is rejected
        expect {
          AuthService.validate_jwt(tampered_token)
        }.to raise_error(AuthenticationError) do |error|
          expect(error.code).to eq(:token_invalid)
        end
      }
    end

    it 'ensures JWT tokens contain all required claims and maintain data integrity' do
      test_instance = self
      
      property_of {
        # Generate various user scenarios
        user_data = test_instance.generate_valid_user_credentials
        user_data
      }.check(10) { |user_data|  # Reduced iterations for faster execution
        # Create user and generate JWT token
        user = create_legacy_compatible_user(user_data)
        jwt_token = AuthService.generate_jwt(user)
        
        # Validate token and get payload
        auth_data = AuthService.validate_jwt(jwt_token)
        payload = auth_data[:payload]
        
        # Verify all required standard JWT claims are present
        expect(payload).to have_key('iss') # Issuer
        expect(payload).to have_key('iat') # Issued at
        expect(payload).to have_key('exp') # Expiration
        expect(payload).to have_key('nbf') # Not before
        expect(payload).to have_key('sub') # Subject
        expect(payload).to have_key('jti') # JWT ID
        
        # Verify all required custom claims are present
        expect(payload).to have_key('user_id')
        expect(payload).to have_key('username')
        expect(payload).to have_key('email')
        
        # Verify claim values are correct
        expect(payload['iss']).to eq('spotik-ruby')
        expect(payload['sub']).to eq(user.id.to_s)
        expect(payload['user_id']).to eq(user.id)
        expect(payload['username']).to eq(user.username)
        expect(payload['email']).to eq(user.email)
        
        # Verify timing claims are logical
        expect(payload['iat']).to be_a(Integer)
        expect(payload['exp']).to be_a(Integer)
        expect(payload['nbf']).to be_a(Integer)
        expect(payload['exp']).to be > payload['iat']
        expect(payload['nbf']).to eq(payload['iat'])
        
        # Verify JWT ID is unique and properly formatted
        expect(payload['jti']).to be_a(String)
        expect(payload['jti'].length).to eq(32) # 16 bytes hex = 32 chars
        expect(payload['jti']).to match(/\A[a-f0-9]{32}\z/)
        
        # Verify expiration is set to correct TTL
        expected_exp = payload['iat'] + (SpotikConfig::Settings.jwt_ttl * 60)
        expect(payload['exp']).to eq(expected_exp)
      }
    end

    it 'handles edge cases in JWT token validation properly' do
      test_instance = self
      
      property_of {
        # Generate edge case scenarios
        edge_case = choose(
          :nil_token, :empty_token, :whitespace_token, :malformed_token,
          :incomplete_token, :non_string_token, :very_long_token
        )
        user_data = test_instance.generate_valid_user_credentials
        [edge_case, user_data]
      }.check(10) { |edge_case, user_data|  # Reduced iterations for faster execution
        # Create user for reference
        user = create_legacy_compatible_user(user_data)
        
        # Test edge case scenarios
        case edge_case
        when :nil_token
          result = AuthService.validate_jwt(nil)
          expect(result).to be_nil
          
        when :empty_token
          result = AuthService.validate_jwt('')
          expect(result).to be_nil
          
        when :whitespace_token
          result = AuthService.validate_jwt('   ')
          expect(result).to be_nil
          
        when :malformed_token
          expect {
            AuthService.validate_jwt('not.a.valid.jwt.token')
          }.to raise_error(AuthenticationError) do |error|
            expect(error.code).to eq(:token_invalid)
          end
          
        when :incomplete_token
          expect {
            AuthService.validate_jwt('incomplete.token')
          }.to raise_error(AuthenticationError) do |error|
            expect(error.code).to eq(:token_invalid)
          end
          
        when :non_string_token
          expect {
            AuthService.validate_jwt(12345)
          }.to raise_error(NoMethodError) # Should fail on string methods
          
        when :very_long_token
          long_token = 'a' * 10000 # Very long string
          expect {
            AuthService.validate_jwt(long_token)
          }.to raise_error(AuthenticationError) do |error|
            expect(error.code).to eq(:token_invalid)
          end
        end
      }
    end
  end

  # Helper methods for generating test data

  def generate_valid_user_credentials
    {
      username: generate_username,
      email: generate_email,
      password: generate_password
    }
  end

  def generate_username
    prefixes = ['user', 'test', 'demo', 'admin', 'guest']
    "#{prefixes.sample}_#{SecureRandom.hex(6)}"
  end

  def generate_email
    domains = ['example.com', 'test.org', 'demo.net', 'sample.io']
    "#{SecureRandom.hex(6)}@#{domains.sample}"
  end

  def generate_password
    # Generate passwords that meet validation requirements (min 8 chars)
    password_patterns = [
      "password#{rand(100..999)}",
      "Password#{rand(100..999)}!",
      "#{SecureRandom.hex(4)}Pass123",
      "Test#{rand(1000..9999)}$",
      "#{SecureRandom.alphanumeric(8)}123"
    ]
    
    password_patterns.sample
  end

  def create_legacy_compatible_user(user_data)
    # Create user with Laravel-compatible bcrypt hash
    User.create(
      username: user_data[:username],
      email: user_data[:email].downcase.strip,
      password_hash: BCrypt::Password.create(user_data[:password]),
      created_at: Time.now,
      updated_at: Time.now
    )
  end

  def create_expired_token_within_grace(user, ttl_seconds)
    # Create a token that's expired but within the grace period for refresh
    now = Time.now.to_i
    issued_at = now - ttl_seconds - 30 # Issued before expiration
    expired_at = issued_at + ttl_seconds # Expired 30 seconds ago
    
    payload = {
      iss: 'spotik-ruby',
      iat: issued_at,
      exp: expired_at, # Expired but within grace period
      nbf: issued_at, # Not before should be same as issued at
      sub: user.id.to_s,
      jti: SecureRandom.hex(16),
      user_id: user.id,
      username: user.username,
      email: user.email
    }
    
    JWT.encode(payload, SpotikConfig::Settings.jwt_secret, 'HS256')
  end
end