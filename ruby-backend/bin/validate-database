#!/usr/bin/env ruby
# Database validation script for Ruby Backend Migration
# Validates database connection, schema compatibility, and performance

require 'bundler/setup'
require 'dotenv/load'

# Load configuration
require_relative '../config/settings'
require_relative '../config/database'

def main
  puts "ğŸ” Ruby Backend Database Validation"
  puts "=" * 50
  puts "Environment: #{SpotikConfig::Settings.app_env}"
  puts "Timestamp: #{Time.now.iso8601}"
  puts

  validation_results = {
    connection: false,
    schema: false,
    performance: false,
    overall: false
  }

  begin
    # 1. Test Database Connection
    puts "1. Testing Database Connection..."
    puts "   Host: #{ENV['DB_HOST'] || 'localhost'}"
    puts "   Database: #{ENV['DB_NAME'] || 'spotik'}"
    puts "   User: #{ENV['DB_USER'] || 'spotik_user'}"
    
    connection_start = Time.now
    db_health = SpotikConfig::Database.health_check
    connection_time = ((Time.now - connection_start) * 1000).round(2)
    
    if db_health[:status] == 'healthy'
      puts "   âœ“ Database connection successful (#{connection_time}ms)"
      puts "   âœ“ Connection pool configured: max=#{db_health[:pool_stats][:max_size] || 'N/A'}"
      validation_results[:connection] = true
    else
      puts "   âœ— Database connection failed: #{db_health[:error]}"
      puts "   Response time: #{connection_time}ms"
      return validation_results
    end

    # 2. Validate Schema Compatibility
    puts "\n2. Validating Schema Compatibility..."
    schema_validation = SpotikConfig::Database.validate_schema_compatibility
    
    case schema_validation[:status]
    when 'valid'
      puts "   âœ“ Schema validation passed"
      validation_results[:schema] = true
    when 'warning'
      puts "   âš  Schema validation completed with warnings:"
      schema_validation[:warnings].each { |warning| puts "     - #{warning}" }
      validation_results[:schema] = true  # Still valid but with warnings
    when 'invalid'
      puts "   âœ— Schema validation failed:"
      schema_validation[:errors].each { |error| puts "     - #{error}" }
      return validation_results
    when 'error'
      puts "   âœ— Schema validation error:"
      schema_validation[:errors].each { |error| puts "     - #{error}" }
      return validation_results
    end
    
    # Display table validation details
    puts "\n   Table Validation Details:"
    schema_validation[:tables].each do |table_name, table_info|
      status_icon = case table_info[:status]
      when 'valid' then 'âœ“'
      when 'warning' then 'âš '
      when 'invalid' then 'âœ—'
      else '?'
      end
      
      puts "     #{status_icon} #{table_name}: #{table_info[:columns].keys.length} columns validated"
      
      if table_info[:errors].any?
        table_info[:errors].each { |error| puts "       âœ— #{error}" }
      end
      
      if table_info[:warnings].any?
        table_info[:warnings].each { |warning| puts "       âš  #{warning}" }
      end
    end

    # 3. Performance Tests
    puts "\n3. Testing Database Performance..."
    performance_results = test_database_performance
    
    if performance_results[:overall_status] == 'good'
      puts "   âœ“ Database performance is acceptable"
      validation_results[:performance] = true
    else
      puts "   âš  Database performance issues detected:"
      performance_results[:issues].each { |issue| puts "     - #{issue}" }
      validation_results[:performance] = true  # Don't fail on performance warnings
    end

    # 4. Connection Pool Test
    puts "\n4. Testing Connection Pool..."
    pool_test_results = test_connection_pool
    
    if pool_test_results[:success]
      puts "   âœ“ Connection pool test passed"
      puts "   âœ“ Pool can handle #{pool_test_results[:max_connections]} concurrent connections"
    else
      puts "   âš  Connection pool test issues:"
      pool_test_results[:issues].each { |issue| puts "     - #{issue}" }
    end

    validation_results[:overall] = validation_results.values.all?

  rescue => e
    puts "\nâœ— Validation failed with error: #{e.message}"
    puts "Backtrace:" if SpotikConfig::Settings.app_debug?
    puts e.backtrace.first(5).map { |line| "  #{line}" } if SpotikConfig::Settings.app_debug?
    return validation_results
  ensure
    # Clean up database connection
    SpotikConfig::Database.close_connection
  end

  # Summary
  puts "\n" + "=" * 50
  puts "VALIDATION SUMMARY"
  puts "=" * 50
  
  validation_results.each do |test, passed|
    status = passed ? "âœ“ PASSED" : "âœ— FAILED"
    puts "#{test.to_s.capitalize.ljust(15)}: #{status}"
  end
  
  if validation_results[:overall]
    puts "\nğŸ‰ Overall Status: PASSED"
    puts "   The Ruby backend is ready to connect to the Laravel database."
    puts "   All schema compatibility checks passed."
    puts "   Database performance is acceptable."
    exit 0
  else
    puts "\nâŒ Overall Status: FAILED"
    puts "   The Ruby backend is not ready for production."
    puts "   Please fix the issues above before proceeding."
    exit 1
  end
end

def test_database_performance
  results = {
    overall_status: 'good',
    issues: [],
    tests: {}
  }
  
  begin
    db = SpotikConfig::Database.connection
    
    # Test 1: Simple query performance
    start_time = Time.now
    db.fetch("SELECT 1").first
    simple_query_time = ((Time.now - start_time) * 1000).round(2)
    results[:tests][:simple_query] = simple_query_time
    
    puts "     Simple query: #{simple_query_time}ms"
    
    if simple_query_time > 100
      results[:overall_status] = 'warning'
      results[:issues] << "Simple query took #{simple_query_time}ms (expected < 100ms)"
    end
    
    # Test 2: Table count queries (if tables exist)
    if db.table_exists?(:users)
      start_time = Time.now
      user_count = db[:users].count
      count_query_time = ((Time.now - start_time) * 1000).round(2)
      results[:tests][:count_query] = count_query_time
      
      puts "     Count query (#{user_count} users): #{count_query_time}ms"
      
      if count_query_time > 500
        results[:overall_status] = 'warning'
        results[:issues] << "Count query took #{count_query_time}ms (expected < 500ms)"
      end
    end
    
    # Test 3: Connection pool response time
    start_time = Time.now
    5.times { db.test_connection }
    pool_test_time = ((Time.now - start_time) * 1000).round(2)
    results[:tests][:pool_test] = pool_test_time
    
    puts "     Connection pool (5 tests): #{pool_test_time}ms"
    
    if pool_test_time > 1000
      results[:overall_status] = 'warning'
      results[:issues] << "Connection pool test took #{pool_test_time}ms (expected < 1000ms)"
    end
    
  rescue => e
    results[:overall_status] = 'error'
    results[:issues] << "Performance test failed: #{e.message}"
  end
  
  results
end

def test_connection_pool
  results = {
    success: true,
    issues: [],
    max_connections: 0
  }
  
  begin
    db = SpotikConfig::Database.connection
    pool_stats = SpotikConfig::Database.get_pool_stats
    
    if pool_stats.empty?
      results[:issues] << "Could not retrieve connection pool statistics"
      return results
    end
    
    max_size = pool_stats[:max_size] || 10
    results[:max_connections] = max_size
    
    # Test that we can get pool information
    if pool_stats[:size] && pool_stats[:allocated]
      puts "     Pool size: #{pool_stats[:size]}/#{max_size}"
      puts "     Allocated: #{pool_stats[:allocated]}"
      puts "     Available: #{pool_stats[:available] || 'N/A'}"
    else
      results[:issues] << "Incomplete pool statistics available"
    end
    
    # Test multiple connections (simulate concurrent usage)
    connection_test_count = [max_size / 2, 3].min
    start_time = Time.now
    
    connection_test_count.times do |i|
      db.test_connection
    end
    
    total_time = ((Time.now - start_time) * 1000).round(2)
    puts "     Concurrent test (#{connection_test_count} connections): #{total_time}ms"
    
    if total_time > 2000
      results[:issues] << "Concurrent connection test took #{total_time}ms (expected < 2000ms)"
    end
    
  rescue => e
    results[:success] = false
    results[:issues] << "Connection pool test failed: #{e.message}"
  end
  
  results
end

# Run the validation if this script is executed directly
if __FILE__ == $0
  main
end